import time
import os

'''
Description:
This module makes it super easy to launch graphical programs
and set them in the correct desktops, at specific locations
in the screen, etc. in a fully automated way.

Todo:
    * Allow to pass logname to launch.
'''
f = open("/home/devel1/log.txt","w")
f.write("In the LogInSkype.py \n")
import subprocess
f.write("subprocess OK \n")
from time import sleep
import re
f.write("re ok \n")
import sys
import shlex
f.write("shlex ok \n")
import argparse
from pynput import mouse,keyboard
f.write("pynput ok end modules\n")




# Make sure xdotools is installed
try:
	subprocess.Popen('xdotool', stdout=subprocess.PIPE,stderr=subprocess.PIPE)
	f.write("xdotool ok\n")
except OSError as e:
	if 'No such file' in e.args[1]:
		print("ERROR: The program 'xdotool' is not installed. Use "\
		      "'sudo apt-get install xdotool' to install it.")
		sys.exit(1)

PRODUCE_SCRIPT=False
LAUNCHED=[]


#Imported from winlaunch : https://github.com/Pithikos/winlaunch
# ------------------------- Starting processes -------------------------

def pid_to_cmd(pid):
    ''' Get the command to a process'''
    out = get_cmd_output('ps -o args %s' % pid)
    return out[0].split('\n')[1].strip()

def run_cmd(cmd):
	''' Run a command '''
	proc = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE,
	                                        stderr=subprocess.PIPE)
	return proc

def get_proc_output(proc):
	out, err = proc.communicate()
	return out.decode("UTF-8"), err.decode("UTF-8")

def get_cmd_output(cmd):
	''' Run a command and get its output'''
	return get_proc_output(run_cmd(cmd))

def launch(cmd):
	''' Run a gui application '''
	open_windows = current_windows()
	print(open_windows)
	
	subprocess.call("export DISPLAY=:0 ; " + cmd, shell = True)
	# Wait for new proc to open GUI
	new_wids = [wid for wid in current_windows() if wid not in open_windows]
	while (len(new_wids) == 0):
		#open_windows = current_windows()
		#subprocess.call(cmd, shell = True)
		sleep(0.1)
		new_wids = [wid for wid in current_windows() if wid not in open_windows]
		#print (current_windows())
	
	if len(new_wids) > 1:
		print('ERROR: launch(): too many window ids found')
		return None
	if len(new_wids) < 1:
		print('ERROR: launch(): too few window ids found')
		return None
	#LAUNCHED.append([cmd, wid])
	wid = int(new_wids[0], 16)
	pid = win_pid(wid)
	LAUNCHED.append([cmd, wid]) #Change from Romain Barbau
	print (wid)
	return wid, pid

#@author Romain Barbau
def sameList(l1,l2):
	if len(l1) == len (l2):
		for i in range(len(l1)):
			if l1[i] != l2[i]:
				return False
		return True
	else:
		return False

# -------------------------------- X Win -------------------------------

def xdo(do):
	out, err = get_cmd_output('xdotool ' + do)
	if err:
		print('ERROR: %s' % err)
	return out

def win_pid(wid):
	''' Gives the PID of the process that window belongs to '''
	return xdo('getwindowpid %s' % wid).strip()

def current_windows():
	''' Gives a list with all open windows '''
	out, err = get_cmd_output('xprop -root')
	match = re.search(r'_NET_CLIENT_LIST_STACKING\(WINDOW\): window id # (.*)', out)
	if not match:
		return None
	return match.group(1).split(', ')

def win_name(wid):
    ''' Gives the name of a window '''
    return xdo('getwindowname %s' % wid).strip()

def win_size(wid, x=None, y=None):
	if x is None or y is None:
		out = xdo('getwindowgeometry %s' % wid)
		match = re.search(r'Geometry: (.*)', out)
		if not match:
			return None
		return map(int, match.group(1).split('x'))
	else:
		xdo('windowsize %s %s %s' % (wid, x, y))
		
#Change from Romain Barbau
def win_pos(wid, x=None, y=None):
	if x is None or y is None:
		out = xdo('getwindowgeometry %s' % wid)
		words = re.split('\W+',out)
		x = int(words[3])
		y = int(words[4])
		#match = re.search(r'Position: (\d*,\d*)', out)
		#if not match:
		#	return None
		#return map(int, match.group(1).split(','))
		return x,y
	else:
		xdo('windowmove %s %s %s' % (wid, x, y))

def win_screen(wid):
	out = xdo('getwindowgeometry %s' % wid)
	match = re.search(r'Position: \d*,\d* \(screen: (\d*)\)', out)
	if not match:
		return None
	return int(match.group(1))

def win_desktop(wid, desktop=None):
	''' Gives the desktop number of the given window '''
	if desktop is None:
		return int(xdo('get_desktop_for_window %s' % wid).strip())
	else:
		return xdo('set_desktop_for_window %s %desktop' % (wid, desktop))

def win_exists(wid):
    out, err = get_cmd_output('xdotool getwindowname %s' % wid)
    if err:
        return False
    else:
        return True




# ---------------------- Auto generating scripts -----------------------

class scriptify:

    script_header = """#! /usr/bin/python\n"""\
                    """# script generated by winlaunch\n"""\
                    """from winlaunch import *\n\n"""

    @staticmethod
    def launched_windows(filename='launch_script.py'):
        f=open(filename, 'w')

        lines=[]
        for cmd, wid in LAUNCHED:
            if win_exists(wid):
                name = win_name(wid).split(' - ')[-1]
                lines.append("# %s" % name)
                lines.append("wid, pid = launch('%s')" % cmd)
                lines.append("win_size(wid, %s, %s)" % tuple(win_size(wid)))
                lines.append("win_pos(wid, %s, %s)" % tuple(win_pos(wid)))
                lines.append("win_desktop(wid, %s)" % win_desktop(wid))
                lines.append("")

        f.write(scriptify.script_header)
        for line in lines:
            f.write(line + '\n')
        f.close()

        return filename


    @staticmethod
    def open_windows(filename='launch_script.py'):
        f=open(filename, 'w')

        lines=[]
        for wid in current_windows():
            if win_exists(wid):
                pid = win_pid(wid)
                name = win_name(wid).split(' - ')[-1]
                lines.append("# %s" % name)
                lines.append("wid, pid = launch('%s')" % pid_to_cmd(pid))
                lines.append("win_size(wid, %s, %s)" % tuple(win_size(wid)))
                lines.append("win_pos(wid, %s, %s)" % tuple(win_pos(wid)))
                lines.append("win_desktop(wid, %s)" % win_desktop(wid))
                lines.append("")

        f.write(scriptify.script_header)
        for line in lines:
            f.write(line + '\n')
        f.close()

        return filename



#@author Romain Barbau

def main(sim_t, Id):
	Mouse = mouse.Controller()
	Keyboard = keyboard.Controller()
	print ("Please Wait while Skype is opening...")

	wid, pid = launch("skypeforlinux --dbpath=/home/devel1/.Skype/ --secondary &")
	sleep(5)#Wait for the graphical interface to be set
	x,y = win_pos(wid)
	print ("We're moving...")
	open_windows = current_windows()
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	#Enter your microsoft ID (email)
	if (Id == 1):
		Keyboard.type("h359085@mvrht.net")
	elif (Id == 2):
		Keyboard.type("j311582@mvrht.net")
	elif (Id == 3):
		Keyboard.type("j312817@mvrht.net")
	#Continue
	sleep(0.2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.press(keyboard.Key.tab)
	Keyboard.release(keyboard.Key.tab)
	sleep(0.2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.press(keyboard.Key.tab)
	Keyboard.release(keyboard.Key.tab)
	sleep(0.2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.press(keyboard.Key.enter)
	Keyboard.release(keyboard.Key.enter)
	sleep(3)
	#Enter your password
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.type("devel1devel1")
	#Log In / Confirm
	sleep(0.2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.press(keyboard.Key.tab)
	Keyboard.release(keyboard.Key.tab)
	sleep(0.2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.press(keyboard.Key.tab)
	Keyboard.release(keyboard.Key.tab)
	sleep(0.2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Keyboard.press(keyboard.Key.enter)
	Keyboard.release(keyboard.Key.enter)
	#Wait for the call...
	width, height = win_size(wid)
	timer = 0
	while (timer < sim_t):#We try to respond any call during 3 minute (we have to stop the script if openbach doesn't do it)
		sleep(1)
		subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
		Mouse.position = x + width - 100,y + 90
		Mouse.press(mouse.Button.left)
		Mouse.release(mouse.Button.left)
		timer += 2
		
	#Disconnect from Skype
	sleep(0.5)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Mouse.position = x + 20,y + 10
	Mouse.press(mouse.Button.left)
	Mouse.release(mouse.Button.left)
	sleep(0.5)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Mouse.position = x + 20,y + 135
	Mouse.press(mouse.Button.left)
	Mouse.release(mouse.Button.left)
	#Close the final skype window.
	sleep(2)
	subprocess.call("xdotool windowactivate {0}".format(wid), shell=True)#Set the right window on the foreground
	Mouse.position = x + 15, y - 10
	Mouse.press(mouse.Button.left)
	Mouse.release(mouse.Button.left)


if __name__ == "__main__":
	# Define Usage
	parser = argparse.ArgumentParser(description='', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
	parser.add_argument('-t', '--sim_t', type=int, default=60, help='Time after which the window skype will be closed. Should be bigger than the sim_t of the skype call (Default = 120 sec).')
	parser.add_argument('-id','--id', type=int, default=1, help='The id of the skype pair. Knowing that we can\'t have 2 same id call instances on the same computer.Values can be 1,2,3 ... (Default = 1).')
	# get args
	args = parser.parse_args()
	sim_t = args.sim_t
	Id = args.id

	main(sim_t, Id)

